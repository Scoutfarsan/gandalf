#!/usr/bin/env bash
set -euo pipefail

REPO_DIR="${REPO_DIR:-/home/pi/gandalf-ops}"
RULES_DIR="${RULES_DIR:-$REPO_DIR/pihole-rules}"
DB="${DB:-/etc/pihole/gravity.db}"
LOG="/var/log/pihole-policy-apply.log"

# Default: stoppa FTL under apply för att undvika sqlite-lock
STOP_FTL="${STOP_FTL:-1}"

ts(){ date '+%F %T'; }
say(){ echo "$(ts) [pihole-policy] $*" | tee -a "$LOG" >/dev/null; }
need(){ command -v "$1" >/dev/null 2>&1 || { echo "Missing: $1" >&2; exit 2; }; }

need sqlite3
need pihole
need awk
need sed
need grep
need systemctl

sql(){
  # Busy timeout utan att skriva "8000" i stdout (annars förstörs variabler)
  sqlite3 -cmd "PRAGMA busy_timeout=8000;" "$DB" "$1"
}

# git pull som pi (root saknar ofta ssh-nycklar)
if [[ -d "$REPO_DIR/.git" ]]; then
  say "git pull (as pi, best effort)"
  sudo -u pi git -C "$REPO_DIR" pull --ff-only >>"$LOG" 2>&1 || true
fi

if [[ ! -f "$DB" ]]; then
  say "ERROR: gravity.db not found at $DB"
  exit 2
fi

# Stoppa FTL för att släppa sqlite-lock under apply
FTL_WAS_ACTIVE=0
cleanup(){
  if (( STOP_FTL == 1 )) && (( FTL_WAS_ACTIVE == 1 )); then
    say "Starting pihole-FTL (restore)"
    systemctl start pihole-FTL >/dev/null 2>&1 || true
  fi
}
trap cleanup EXIT

if (( STOP_FTL == 1 )); then
  if systemctl is-active --quiet pihole-FTL 2>/dev/null; then
    FTL_WAS_ACTIVE=1
    say "Stopping pihole-FTL to avoid sqlite lock"
    systemctl stop pihole-FTL >/dev/null 2>&1 || true
  fi
fi

# Detect client table columns (Pi-hole schema varierar)
HAS_CLIENT_NAME=0
HAS_CLIENT_IP=0
CLIENT_HW_COL=""

while IFS='|' read -r _ col _; do
  case "$col" in
    name) HAS_CLIENT_NAME=1 ;;
    ip)   HAS_CLIENT_IP=1 ;;
    hwaddr|mac|hardware_address) CLIENT_HW_COL="$col" ;;
  esac
done < <(sql "PRAGMA table_info(client);")

say "client schema: ip=$HAS_CLIENT_IP name=$HAS_CLIENT_NAME hw_col=${CLIENT_HW_COL:-none}"

ensure_group(){
  local g="$1"
  local id
  id="$(sql "SELECT id FROM 'group' WHERE name='$g' LIMIT 1;")"
  if [[ -z "$id" ]]; then
    say "Create group: $g"
    sql "INSERT INTO 'group'(enabled,name,description) VALUES(1,'$g','managed by policy-as-code');"
  fi
}
group_id(){ sql "SELECT id FROM 'group' WHERE name='$1' LIMIT 1;"; }

ensure_domainlist(){
  local type="$1" domain="$2" comment="$3"
  local id
  id="$(sql "SELECT id FROM domainlist WHERE type=$type AND domain='$domain' LIMIT 1;")"
  if [[ -z "$id" ]]; then
    say "Add domainlist: type=$type $domain"
    sql "INSERT INTO domainlist(type,domain,enabled,comment) VALUES($type,'$domain',1,'$comment');"
  fi
  sql "SELECT id FROM domainlist WHERE type=$type AND domain='$domain' LIMIT 1;"
}

bind_domain_to_group(){
  local domain_id="$1" group_id="$2"
  local exists
  exists="$(sql "SELECT 1 FROM domainlist_by_group WHERE domainlist_id=$domain_id AND group_id=$group_id LIMIT 1;")"
  if [[ -z "$exists" ]]; then
    sql "INSERT INTO domainlist_by_group(domainlist_id,group_id) VALUES($domain_id,$group_id);"
  fi
}

ensure_adlist(){
  local url="$1"
  local id
  id="$(sql "SELECT id FROM adlist WHERE address='$url' LIMIT 1;")"
  if [[ -z "$id" ]]; then
    say "Add adlist: $url"
    sql "INSERT INTO adlist(address,enabled,comment) VALUES('$url',1,'managed by policy-as-code');"
  fi
}

bind_adlist_all_groups(){
  local url="$1"
  local ad_id gid exists
  ad_id="$(sql "SELECT id FROM adlist WHERE address='$url' LIMIT 1;")"
  [[ -z "$ad_id" ]] && return 0
  while IFS= read -r gid; do
    [[ -z "$gid" ]] && continue
    exists="$(sql "SELECT 1 FROM adlist_by_group WHERE adlist_id=$ad_id AND group_id=$gid LIMIT 1;")"
    if [[ -z "$exists" ]]; then
      sql "INSERT INTO adlist_by_group(adlist_id,group_id) VALUES($ad_id,$gid);"
    fi
  done < <(sql "SELECT id FROM 'group';")
}

ensure_client(){
  local client="$1" comment="$2"
  local id=""

  # IP
  if [[ "$client" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] && (( HAS_CLIENT_IP == 1 )); then
    id="$(sql "SELECT id FROM client WHERE ip='$client' LIMIT 1;")"
    if [[ -z "$id" ]]; then
      sql "INSERT INTO client(ip,comment) VALUES('$client','$comment');"
      id="$(sql "SELECT id FROM client WHERE ip='$client' LIMIT 1;")"
    fi
    echo "$id"; return 0
  fi

  # MAC
  if [[ "$client" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] && [[ -n "${CLIENT_HW_COL:-}" ]]; then
    id="$(sql "SELECT id FROM client WHERE $CLIENT_HW_COL='$client' LIMIT 1;")"
    if [[ -z "$id" ]]; then
      sql "INSERT INTO client($CLIENT_HW_COL,comment) VALUES('$client','$comment');"
      id="$(sql "SELECT id FROM client WHERE $CLIENT_HW_COL='$client' LIMIT 1;")"
    fi
    echo "$id"; return 0
  fi

  # NAME (om den finns)
  if (( HAS_CLIENT_NAME == 1 )); then
    id="$(sql "SELECT id FROM client WHERE name='$client' LIMIT 1;")"
    if [[ -z "$id" ]]; then
      sql "INSERT INTO client(name,comment) VALUES('$client','$comment');"
      id="$(sql "SELECT id FROM client WHERE name='$client' LIMIT 1;")"
    fi
    echo "$id"; return 0
  fi

  say "WARN: client '$client' could not be stored (no suitable column). Use IP or MAC."
  echo ""
}

bind_client_group(){
  local client_id="$1" group_id="$2"
  [[ -z "$client_id" || -z "$group_id" ]] && return 0
  local exists
  exists="$(sql "SELECT 1 FROM client_by_group WHERE client_id=$client_id AND group_id=$group_id LIMIT 1;")"
  if [[ -z "$exists" ]]; then
    sql "INSERT INTO client_by_group(client_id,group_id) VALUES($client_id,$group_id);"
  fi
}

read_lines(){
  local file="$1"
  [[ -f "$file" ]] || return 0
  grep -v '^[[:space:]]*#' "$file" | sed '/^[[:space:]]*$/d'
}

say "Apply groups..."
while IFS= read -r g; do
  [[ -z "$g" ]] && continue
  ensure_group "$g"
done < <(read_lines "$RULES_DIR/groups.txt")

say "Apply clients..."
if [[ -f "$RULES_DIR/clients.csv" ]]; then
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    IFS=',' read -r client group comment <<<"$line"
    client="$(echo "${client:-}" | sed 's/[[:space:]]//g')"
    group="$(echo "${group:-}" | sed 's/[[:space:]]//g')"
    comment="${comment:-managed}"
    [[ -z "$client" || -z "$group" ]] && continue
    ensure_group "$group"
    cid="$(ensure_client "$client" "$comment")"
    gid="$(group_id "$group")"
    bind_client_group "$cid" "$gid"
  done < "$RULES_DIR/clients.csv"
fi

say "Apply adlists..."
while IFS= read -r url; do
  [[ -z "$url" ]] && continue
  ensure_adlist "$url"
  bind_adlist_all_groups "$url"
done < <(read_lines "$RULES_DIR/adlists.txt")

ALL_GIDS=()
while IFS= read -r gid; do ALL_GIDS+=("$gid"); done < <(sql "SELECT id FROM 'group' WHERE enabled=1;")
ALEX_GID="$(group_id "Alexander" || true)"

say "Apply ALWAYS-ALLOW regex (type=4) to ALL groups..."
while IFS= read -r rx; do
  [[ -z "$rx" ]] && continue
  did="$(ensure_domainlist 4 "$rx" "always-allow")"
  for gid in "${ALL_GIDS[@]}"; do bind_domain_to_group "$did" "$gid"; done
done < <(read_lines "$RULES_DIR/allow_regex_always.txt")

say "Apply GLOBAL BLOCK regex (type=3) to ALL groups..."
while IFS= read -r rx; do
  [[ -z "$rx" ]] && continue
  did="$(ensure_domainlist 3 "$rx" "global-block")"
  for gid in "${ALL_GIDS[@]}"; do bind_domain_to_group "$did" "$gid"; done
done < <(read_lines "$RULES_DIR/block_regex_global.txt")

say "Apply EXCEPT-ALEXANDER BLOCK regex (type=3) to all groups except Alexander..."
while IFS= read -r rx; do
  [[ -z "$rx" ]] && continue
  did="$(ensure_domainlist 3 "$rx" "block-except-alexander")"
  for gid in "${ALL_GIDS[@]}"; do
    if [[ -n "${ALEX_GID:-}" && "$gid" == "$ALEX_GID" ]]; then
      continue
    fi
    bind_domain_to_group "$did" "$gid"
  done
done < <(read_lines "$RULES_DIR/block_regex_except_alexander.txt")

APPS_ALLOW="${APPS_ALLOW:-0}"
if (( APPS_ALLOW == 1 )); then
  say "Apply APPS allow regex to ALL groups (APPS_ALLOW=1)..."
  while IFS= read -r rx; do
    [[ -z "$rx" ]] && continue
    did="$(ensure_domainlist 4 "$rx" "apps-allow")"
    for gid in "${ALL_GIDS[@]}"; do bind_domain_to_group "$did" "$gid"; done
  done < <(read_lines "$RULES_DIR/allow_regex_apps.txt")
else
  say "APPS_ALLOW=0 (skip allow_regex_apps.txt)"
fi

BLOCKALL_RX="$(read_lines "$RULES_DIR/blockall_regex.txt" | head -n1 || true)"
if [[ -n "${BLOCKALL_RX:-}" ]]; then
  BLOCKALL_ID="$(ensure_domainlist 3 "$BLOCKALL_RX" "blockall-scheduled")"
  mkdir -p /var/lib/gandalf
  echo "$BLOCKALL_ID" > /var/lib/gandalf/pihole_blockall_domainlist_id
  say "Blockall rule id=$BLOCKALL_ID stored"
fi

# Starta FTL igen innan pihole-kommandon (de förutsätter ofta att FTL kör)
if (( STOP_FTL == 1 )) && (( FTL_WAS_ACTIVE == 1 )); then
  say "Starting pihole-FTL before gravity/restartdns"
  systemctl start pihole-FTL >/dev/null 2>&1 || true
  FTL_WAS_ACTIVE=0
fi

say "Rebuild gravity..."
pihole -g >>"$LOG" 2>&1 || true

say "Restart DNS..."
pihole restartdns >>"$LOG" 2>&1 || true

say "OK: policy applied."
echo "OK"
